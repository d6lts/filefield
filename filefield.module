<?php
// $Id$
/**
 * @file
 * FileField: Defines a CCK file field type.
 *
 * Uses content.module to store the fid and field specific metadata,
 * and Drupal's {files} table to store the actual file data.
 */

include_once(drupal_get_path('module', 'filefield') .'/field_file.inc');

/**
 * Implementation of hook_menu().
 */
function filefield_menu() {
  $items = array();

  $items['filefield/js/upload/%/%/%'] = array(
    'page callback' => 'filefield_js',
    'page arguments' => array(3, 4, 5, 'filefield_file_upload_js'),
    'access callback' => 'filefield_edit_access',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK,
  );
  $items['filefield/js/delete/%/%/%'] = array(
    'page callback' => 'filefield_js',
    'page arguments' => array(3, 4, 5, 'filefield_file_edit_delete_js'),
    'access callback' => 'filefield_edit_access',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Access callback for the JavaScript upload and deletion AHAH callbacks.
 * The content_permissions module provides nice fine-grained permissions for
 * us to check, so we can make sure that the user may actually edit the file.
 */
function filefield_edit_access($field_name) {
  if (module_exists('content_permissions')) {
    return user_access('edit '. $field_name);
  }
  // No content permissions to check, so let's fall back to a more general permission.
  return user_access('access content');
}

/**
 * Access callback that checks if the current user may view the filefield.
 */
function filefield_view_access($field_name) {
  if (module_exists('content_permissions')) {
    return user_access('view '. $field_name);
  }
  // No content permissions to check, so let's fall back to a more general permission.
  return user_access('access content');
}

/**
 * Implementation of hook_elements().
 */
function filefield_elements() {
  $elements = array();
  $elements['filefield_file_upload'] = array(
    '#input' => TRUE,
    '#process' => array('filefield_file_upload_process'),
    '#element_validate' => array(), // later filled with 'filefield_file_upload_validate'
    '#value_callback' => 'filefield_file_upload_value',
    '#replaced_file' => NULL,
  );
  $elements['filefield_file_edit'] = array(
    '#input' => TRUE,
    '#process' => array('filefield_file_edit_process'),
    '#value_callback' => 'filefield_file_edit_value',
  );
  $elements['filefield_generic_edit'] = array(
    '#input' => TRUE,
    '#process' => array('filefield_generic_edit_process'),
  );
  return $elements;
}

/**
 * Implementation of hook_theme().
 */
function filefield_theme() {
  return array(
    'filefield_draggable_settings_table' => array(
      'arguments' => array('element' => NULL),
    ),
    'filefield_container_item' => array(
      'arguments' => array('element' => NULL),
    ),
    'filefield_file_upload' => array(
      'arguments' => array('element' => NULL),
    ),
    'filefield_file_edit' => array(
      'arguments' => array('element' => NULL),
    ),
    'filefield_generic_edit' => array(
      'arguments' => array('element' => NULL),
    ),
    'filefield_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'filefield_unguarded' => array(
      'arguments' => array('field' => NULL, 'file' => NULL),
    ),
    'filefield' => array(
      'arguments' => array('field' => NULL, 'file' => NULL),
    ),
    'filefield_file_formatter_generic' => array(
      'arguments' => array('field' => NULL, 'file' => NULL),
    ),
    'filefield_icon' => array(
      'arguments' => array('file' => NULL),
    ),
  );
}

/**
 * Theme function for a file formatter / file widget settings table.
 */
function theme_filefield_draggable_settings_table($element) {
  $settings_type = $element['#settings_type']; // 'widgets' or 'formatters'?
  $table_id = 'filefield-file-'. $settings_type .'-table';
  $order_class = 'filefield-file-'. $settings_type .'-weight';

  $widget_info = $element['#widget_info'];
  $title = isset($element['#title']) ? $element['#title'] : '';
  unset($element['#title']); // the header is used instead of the regular label

  $header = array(t('@title:', array('@title' => $title)), t('Order'));
  $rows = array();

  foreach (element_children($element) as $key) {
    $element[$key]['weight']['#attributes']['class'] = $order_class;
    $delta_element = drupal_render($element[$key]['weight']);
    $row = array(
      drupal_render($element[$key]),
      $delta_element,
    );
    $rows[] = array('data' => $row, 'class' => 'draggable');
  }
  $output = theme('table', $header, $rows, array('id' => $table_id));
  $output = theme('form_element', $element, $output);

  drupal_add_tabledrag($table_id, 'order', 'sibling', $order_class);

  return $output;
}


/**
 * Implementation of hook_field_info().
 */
function filefield_field_info() {
  return array(
    'file' => array(
      'label' => 'File',
      'description' => t('Store an arbitrary file.'),
    ),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function filefield_field_settings($op, $field) {
  switch ($op) {
    case 'form':
      $form = array();
      $form['force_list'] = array(
        '#type' => 'checkbox',
        '#title' => t('Always list files'),
        '#default_value' => isset($field['force_list']) ? $field['force_list'] : 0,
        '#description' => t('If enabled, the "List" checkbox will be hidden and files are always shown. Otherwise, the user can choose for each file whether it should be listed or not.'),
      );

      $form['file_formatters'] = array(
        '#title' => t('File display'),
        '#description' => t('Control how files may be displayed in the node view and other views for this field. If no formatters are enabled or are able to handle a file then that specific file will not be displayed. You can also reorder the formatters to specify their priority: the top-most enabled formatter always gets to display the files that it supports, whereas the bottom-most enabled formatter only gets to handle them if the file is not supported by any other other one.'),
        '#tree' => TRUE,
        '#weight' => 5,
        '#theme' => 'filefield_draggable_settings_table',
        '#settings_type' => 'formatters', // info for the theme function
      );

      $file_formatter_info = _filefield_file_formatter_info($field);

      // Present the formatters in the order that was determined above.
      $weight = 1;
      foreach ($file_formatter_info as $file_formatter => $info) {
        $form['file_formatters'][$file_formatter]['enabled'] = array(
          '#type' => 'checkbox',
          '#title' => $info['title'],
          '#description' => $info['description'],
          '#default_value' => $info['enabled'],
        );
        $form['file_formatters'][$file_formatter]['weight'] = array(
          '#type' => 'weight',
          '#delta' => count($file_formatter_info),
          '#default_value' => $weight,
        );

        // Let modules add their own formatter specific settings.
        $file_formatter_settings = isset($field['file_formatters'][$file_formatter])
                                    ? $field['file_formatters'][$file_formatter]
                                    : array();
        $additions = module_invoke(
          $info['module'], 'file_formatter_settings_'. $info['name'],
          'form', $file_formatter_settings
        );
        if (is_array($additions)) {
          $form['file_formatters'][$file_formatter] = array_merge(
            $form['file_formatters'][$file_formatter], $additions
          );
        }
        ++$weight;
      }
      return $form;

    case 'validate':
      // Let modules add their own formatter specific validations.
      $file_formatter_info = _filefield_file_formatter_info($widget);

      foreach ($file_formatter_info as $file_formatter => $info) {
        $file_formatter_settings = isset($field['file_formatters'][$file_formatter])
                                    ? $field['file_formatters'][$file_formatter]
                                    : array();
        module_invoke(
          $info['module'], 'file_formatter_settings_'. $info['name'],
          'validate', $file_formatter_settings
        );
      }
      break;

    case 'save':
      return array('force_list', 'file_formatters');

    case 'database columns':
      $columns = array(
        'fid' => array('type' => 'int', 'not null' => FALSE),
        'description' => array('type' => 'varchar', 'length' => 255, 'not null' => FALSE, 'sortable' => TRUE),
        'list' => array('type' => 'int', 'size' => 'tiny', 'not null' => FALSE),
      );
      return $columns;

    case 'views data':
      $data = content_views_field_views_data($field);
      $db_info = content_database_info($field);
      $table_alias = content_views_tablename($field);

      // By defining the relationship, we already have a "Has file" filter
      // plus all the filters that Views already provides for files.
      // No need for having a filter by ourselves.
      unset($data[$table_alias][$field['field_name'] .'_fid']['filter']);

      // Add a relationship for related file.
      $data[$table_alias][$field['field_name'] .'_fid']['relationship'] = array(
        'base' => 'files',
        'field' => $db_info['columns']['fid']['column'],
        'handler' => 'views_handler_relationship',
      );
      return $data;
  }
}

/**
 * Implementation of hook_content_is_empty().
 *
 * The result of this determines whether content.module will save
 * the value of the field.
 */
function filefield_content_is_empty($item, $field) {
  if (empty($item['fid'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implementation of hook_field().
 */
function filefield_field($op, $node, $field, &$items, $teaser, $page) {
  $field_name = $field['field_name'];

  switch ($op) {
    // Called after content.module loads default data.
    case 'load':
      if (empty($items)) {
        return array();
      }
      foreach ($items as $delta => $item) {
        // Despite hook_content_is_empty(), CCK still doesn't filter out
        // empty items from $op = 'load', so we need to do that ourselves.
        if (empty($item['fid']) || !($file = field_file_load($item['fid']))) {
          unset($items[$delta]);
        }
        else {
          $items[$delta] = array_merge($item, $file);
        }
      }
      $items = array_values($items); // compact deltas
      return array($field_name => $items);

    case 'insert':
    case 'update':
      foreach ($items as $delta => $item) {
        $items[$delta] = field_file_save($node, $item);

        // Remove items from the array if they have been deleted.
        if (empty($items[$delta])) {
          unset($items[$delta]);
        }
      }
      $items = array_values($items); // compact deltas
      break;

    case 'presave':
      // Extract previous (permanent) files from the items array that have been
      // deleted or replaced, so that insert/update can remove them properly.
      foreach ($items as $delta => $item) {
        if (!empty($item['replaced_file'])) {
          $items[] = $item['replaced_file'];
        }
      }
      break;

    case 'delete revision':
      foreach ($items as $delta => $item) {
        if (field_file_delete($item)) {
          $items[$delta] = array();
        }
      }
      $items = array_values($items); // compact deltas
      break;

    case 'delete':
      foreach ($items as $delta => $item) {
        field_file_delete($item);
      }
      break;

    case 'sanitize':
      foreach ($items as $delta => $item) {
        // Cleanup $items during node preview.
        if (empty($item['fid']) || !empty($item['delete'])) {
          unset($items[$delta]);
        }
        else {
          // Load the complete file if a filepath is not available.
          if (!empty($item['fid']) && empty($item['filepath'])) {
            $items[$delta] = array_merge($item, field_file_load($item['fid']));
          }
          // Add nid so formatters can create a link to the node.
          $items[$delta]['nid'] = $node->nid;
        }
      }
      break;
  }
}

/**
 * Implementation of hook_widget_info().
 */
function filefield_widget_info() {
  return array(
    'filefield_combo' => array(
      'label' => 'File',
      'field types' => array('file'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array('default value' => CONTENT_CALLBACK_CUSTOM),
    ),
  );
}

/**
 * Implementation of hook_widget_settings().
 */
function filefield_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      $form = array();
      $form['file_extensions'] = array(
        '#type' => 'textfield',
        '#title' => t('Permitted upload file extensions'),
        '#default_value' => is_string($widget['file_extensions']) ? $widget['file_extensions'] : 'txt',
        '#size' => 64,
        '#description' => t('Extensions a user can upload to this field. Separate extensions with a space and do not include the leading dot. Leaving this blank will allow users to upload a file with any extension.'),
      );
      $form['file_path'] = array(
        '#type' => 'textfield',
        '#title' => t('File path'),
        '#default_value' => is_string($widget['file_path']) ? $widget['file_path'] : '',
        '#description' => t('Optional subdirectory within the "%dir" directory where files will be stored. Do not include trailing slash.', array('%dir' => variable_get('file_directory_path', 'files'))),
        '#element_validate' => array('_filefield_widget_settings_file_path_validate'),
      );
      if (module_exists('token')) {
        $form['file_path']['#suffix'] = theme('token_help', 'user');
      }

      $form['file_widgets'] = array(
        '#title' => t('File widgets'),
        '#description' => t('Control which kinds of files may be uploaded to the edit form for this field, by specifying the widgets that can handle the desired file types. You can also reorder the widgets to specify their priority: the top-most enabled widget always gets to handle the files that it supports, whereas the bottom-most enabled widget only gets to handle them if the file is not supported by any other other one.'),
        '#tree' => TRUE,
        '#weight' => 5,
        '#theme' => 'filefield_draggable_settings_table',
        '#settings_type' => 'widgets', // info for the theme function
      );

      $file_widget_info = _filefield_file_widget_info($widget);

      // Present the widgets in the order that was determined above.
      $weight = 1;
      foreach ($file_widget_info as $file_widget_name => $info) {
        $form['file_widgets'][$file_widget_name]['enabled'] = array(
          '#type' => 'checkbox',
          '#title' => $info['title'],
          '#description' => $info['description'],
          '#default_value' => $info['enabled'],
        );
        $form['file_widgets'][$file_widget_name]['weight'] = array(
          '#type' => 'weight',
          '#delta' => count($file_widget_info),
          '#default_value' => $weight,
        );

        // Let modules add their own widget specific settings.
        $file_widget_settings = isset($widget['file_widgets'][$file_widget_name])
                                ? $widget['file_widgets'][$file_widget_name]
                                : array();
        $additions = module_invoke(
          $info['module'], 'file_widget_settings_'. $info['name'],
          'form', $file_widget_settings
        );
        if (is_array($additions)) {
          $form['file_widgets'][$file_widget_name] = array_merge(
            $form['file_widgets'][$file_widget_name], $additions
          );
        }
        ++$weight;
      }
      return $form;

    case 'validate':
      $valid = FALSE;
      foreach ($widget['file_widgets'] as $file_widget_name => $info) {
        if ($info['enabled']) {
          $valid = TRUE;
          break;
        }
      }
      if (!$valid) {
        form_set_error('file_widgets', t('At least one type of file widgets must be enabled.'));
      }

      // Let modules add their own widget specific validations.
      $file_widget_info = _filefield_file_widget_info($widget);

      foreach ($file_widget_info as $file_widget_name => $info) {
        $file_widget_settings = isset($widget['file_widgets'][$file_widget_name])
                                ? $widget['file_widgets'][$file_widget_name]
                                : array();
        module_invoke(
          $info['module'], 'file_widget_settings_'. $info['name'],
          'validate', $file_widget_settings
        );
      }
      break;

    case 'save':
      return array('file_extensions', 'file_path', 'file_widgets');
  }
}

function _filefield_widget_settings_file_path_validate($element, &$form_state) {
  // Strip slashes from the beginning and end of $widget['file_path']
  $form_state['values']['file_path'] = trim($form_state['values']['file_path'], '\\/');
}

/**
 * Implementation of hook_widget().
 */
function filefield_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  // JavaScript might reload the form element but not the CSS that has been
  // defined inside the process hook of mimetype specific widgets. As we don't
  // know which widget will show up, just include all of their CSS files.
  $file_widget_info = _filefield_file_widget_info($field['widget']);
  _filefield_add_css($file_widget_info);
  drupal_add_css(drupal_get_path('module', 'filefield') .'/filefield.css');

  if (empty($items[$delta])) {
    return filefield_file_upload_form($form, $form_state, $field, $delta);
  }
  if (!$file = field_file_load($items[$delta]['fid'])) {
    return filefield_file_upload_form($form, $form_state, $field, $delta, $items[$delta]);
  }
  $file = array_merge($items[$delta], $file);
  return filefield_file_edit_form($form, $form_state, $field, $delta, $file);
}

/**
 * Render either an upload or edit container item so that the children elements
 * always appear inside a nice table, whatever $field['multiple'] might be.
 */
function theme_filefield_container_item($element) {
  $field = $element['#field'];
  $children = !empty($element['#children']) ? $element['#children'] : '';
  $children = '<div class="ahah-new-content">'. $children .'</div>';

  // CCK renders a nice table for multiple-value fields, that's just fine as is.
  if ($field['multiple']) {
    return $children;
  }
  // If the field is single-value, we still want to have a table, for the looks.
  $header = array();
  $rows = array(array($children));
  $attributes = array('class' => 'filefield-file-container-table');
  $table = theme('table', $header, $rows, $attributes);
  return theme('form_element', $element, $table);
}

/**
 * The filefield widget for not (yet) existing files.
 */
function filefield_file_upload_form(&$form, &$form_state, $field, $delta, $item = NULL) {
  $form['#attributes']['enctype'] = 'multipart/form-data';

  // Include JavaScript for client-side file validation.
  drupal_add_js(drupal_get_path('module', 'filefield') .'/filefield.js');

  $field_name_css = str_replace('_', '-', $field['field_name']);
  $id = 'filefield-'. $field_name_css .'-'. $delta .'-form';

  $replaced_file = (isset($item) && isset($item['replaced_file']))
                    ? $item['replaced_file'] : NULL;

  $widget = array(
    '#type'   => 'filefield_file_upload',
    '#field' => $field,
    '#delta' => $delta,
    '#replaced_file' => $replaced_file,
    '#prefix' => '<div id="'. $id .'" class="filefield-file-form"><div class="filefield-file-upload">',
    '#suffix' => '</div></div>',
  );
  // Buttons inside custom form elements are not registered by the Forms API,
  // so we make the "Upload" button a regular child element and not a part
  // of the filefield_file_upload widget.
  $widget[$field['field_name'] .'_'. $delta .'_upload'] = array(
    '#name' => $field['field_name'] .'_'. $delta .'_upload',
    '#type' => 'submit',
    '#value' => t('Upload'),
    '#submit' => array('filefield_file_upload_submit'), // without JavaScript
    '#ahah' => array( // with JavaScript
      'path' => 'filefield/js/upload/'. $field['field_name'] .'/'. $field['type_name'] .'/'. $delta,
      'wrapper' => $id,
      'method' => 'replace',
      'effect' => 'fade',
    ),
    '#weight' => 10,
    '#field' => $field,
    '#delta' => $delta,
  );
  return $widget;
}

/**
 * The 'process' callback for 'filefield_file_upload' form elements.
 * Called after defining the form and while building it, transforms the
 * barebone element array into a file selection widget.
 */
function filefield_file_upload_process($element, $edit, &$form_state, $form) {
  // Before the element user gets to do his validation, make sure we do ours.
  array_unshift($element['#element_validate'], 'filefield_file_upload_validate');

  $field = $element['#field'];
  $field_name = $field['field_name'];

  // Construct the upload description out of user supplied text,
  // maximum upload file size, and (optionally) allowed extensions.
  $upload_description = t('Maximum file size: !size.', array(
    '!size' => format_size(file_upload_max_size()),
  ));
  if (!empty($field['widget']['file_extensions'])) {
    $upload_description .= ' '. t('Allowed extensions: %ext.', array(
      '%ext' => $field['widget']['file_extensions'],
    ));
  }
  $required_file_widgets = _filefield_required_file_widgets($field['widget']);
  if (!empty($required_file_widgets)) {
    $upload_description .= '<br/>'. t('Additionally, uploads are restricted to the following categories: !widgets.', array('!widgets' => implode(', ', $required_file_widgets)));
  }

  $upload_name = $field_name .'_'. $element['#delta'];
  $element[$upload_name] = array(
    '#type' => 'file',
    '#title' => t('Attach new file'),
    '#description' => $upload_description,
    '#weight' => -1,
    // Emulate how FAPI normalizes the _FILES array since this won't go through form_builder
    '#name' => 'files['. $upload_name .']',
  );

  // User 1 may even upload files with extensions that are not allowed.
  // (At least, that's how core's file_validate_extensions() thinks about it.)
  // So only add the JavaScript extension check for other users.
  global $user;
  if ($user->uid != 1) {
    $element[$upload_name]['#attributes'] = array(
      'accept' => str_replace(' ', '|', trim($field['widget']['file_extensions']))
    );
  }

  return $element;
}

/**
 * Theme function for the file upload container element.
 */
function theme_filefield_file_upload($element) {
  return theme('filefield_container_item', $element);
}

/**
 * Value callback for 'filefield_upload' form elements.
 * Uploads and validates a file if one has been specified,
 * and returns the fid of that file as result value.
 */
function filefield_file_upload_value($element, $edit = FALSE) {
  return empty($element['#value'])
    ? array('fid' => 0, 'replaced_file' => $element['#replaced_file'])
    : $element['#value'];
}

/**
 * The 'validate' callback for 'duration_combo' form elements.
 * Called after values are assigned, before form validate and submit are called.
 */
function filefield_file_upload_validate($element, &$form_state) {
  if (!empty($element['#required']) && empty($element['#value']['fid'])) {
    form_error($element, t('You need to upload a file to the %field field.', array(
      '%field' => $element['#field']['widget']['label']
    )));
  }
}

/**
 * Submit callback for the "Upload" button next to each file upload field.
 */
function filefield_file_upload_submit($form, &$form_state) {
  $field = $form_state['clicked_button']['#field'];
  $delta = $form_state['clicked_button']['#delta'];
  filefield_file_upload($form_state, $field, $delta);

  // Rebuild the form with the new uploaded-file state (hopefully).
  node_form_submit_build_node($form, $form_state);
}

/**
 * Form callback for the "Upload" button with JavaScript enabled,
 * invoked by filefield_js(). Uploads a file to the given field and delta.
 */
function filefield_file_upload_js(&$form, &$form_state, $field, $delta) {
  filefield_file_upload($form_state, $field, $delta);
}

/**
 * Upload a file to the given field and delta (or try to, at least), and
 * update the corresponding part of the form state with the new file data.
 */
function filefield_file_upload(&$form_state, $field, $delta) {
  $field_name = $field['field_name'];
  $file = &$form_state['values'][$field_name][$delta];
  $replaced_file = $file['replaced_file'];

  if (module_exists('token')) {
    global $user;
    $widget_file_path = token_replace($field['widget']['file_path'], 'user', $user);
  }
  else {
    $widget_file_path = $field['widget']['file_path'];
  }

  // Let modules provide their own validators.
  $validators = array_merge(module_invoke_all('filefield_validators'), array(
    'file_validate_extensions' => array($field['widget']['file_extensions']),
    'filefield_validate_file_widget_support' => array($field, $field['widget']),
  ));
  $upload_name = $field_name .'_'. $delta;
  $complete_file_path = file_directory_path() .'/'. $widget_file_path;

  if (!filefield_check_directory($widget_file_path, $upload_name)) {
    watchdog('file', 'The upload directory %directory for the file field %field (content type %type) could not be created or is not accessible. A newly uploaded file could not be saved in this directory as a consequence, and the upload was canceled.', array('%directory' => $widget_file_path, '%field' => $field_name, '%type' => $field['type_name']));
    $file = array('fid' => 0, 'replaced_file' => $replaced_file);
    return $file;
  }
  if (!$file = field_file_save_upload($upload_name, $validators, $complete_file_path)) {
    watchdog('file', 'The file %file could not be saved as addition to the file field %field (content type %type). This can be a consequence of the file failing validation, or if it can\'t be moved to the file directory, or whatever reason the file framework comes up with. No further information is available to the filefield module, but if you\'re lucky then that function left one or more hints in the log as well (directly before this log entry).', array('%file' => $complete_file_path, '%field' => $field_name, '%type' => $field['type_name']));
    $file = array('fid' => 0, 'replaced_file' => $replaced_file);
    return $file;
  }

  $file_default_properties = array(
    'list' => 1,
    'description' => $file['filename'],
  );
  $file = array_merge($file_default_properties, $file);
  $file['replaced_file'] = $replaced_file;
  return $file;
}

/**
 * Check that a file is supported by at least one of the widgets that are
 * enabled for the field instance in question.
 *
 * @return
 *   An array. If the file is not allowed, it will contain an error message.
 */
function filefield_validate_file_widget_support($file, $field, $field_widget) {
  $errors = array();

  // No widgets at all means the widget settings db entry does not exist,
  // so we fall back to "accept this file and use the generic edit widget".
  if (empty($field_widget['file_widgets'])) {
    return $errors;
  }
  // In the common case, we only accept a file if an enabled widget
  // wants to handle it.
  $edit_widget_info = filefield_widget_for_file($field, $field_widget, $file);
  if (empty($edit_widget_info)) {
    $errors[] = t('Uploaded files are restricted to the following categories: !widgets.', array(
      '!widgets' => implode(', ', _filefield_required_file_widgets($field_widget)),
    ));
  }
  return $errors;
}

/**
 * If not all file types might be handled by the enabled set of file widgets,
 * return an array specifying which widgets are allowed for the given field.
 * If a widget is enabled which handles all files, return an empty array.
 */
function _filefield_required_file_widgets($field_widget) {
  if (empty($field_widget['file_widgets'])) {
    return array();
  }
  $titles = array();
  $file_widget_info = _filefield_file_widget_info($field_widget);

  foreach ($file_widget_info as $widget_name => $info) {
    if (!$info['enabled']) {
      continue;
    }
    if ($info['suitability callback'] === TRUE) {
      // Handles all kinds of files, no need for requiring any other widget.
      return array();
    }
    $titles[] = $info['title'];
  }
  return $titles;
}

/**
 * Create the file directory relative to the 'files' dir recursively for every
 * directory in the path.
 *
 * @param $directory
 *   The directory path under files to check, such as 'photo/path/here'.
 * @param $form_item
 *   An optional string containing the name of a form item that any errors
 *   will be attached to. (See field_file_check_directory() for more details.)
 */
function filefield_check_directory($directory, $form_item = NULL) {
  $directory = field_file_strip_path($directory);

  foreach (explode('/', $directory) as $dir) {
    $dirs[] = $dir;
    $path = file_create_path(implode($dirs, '/'));
    if (!field_file_check_directory($path, FILE_CREATE_DIRECTORY, $form_item)) {
      watchdog('filefield', t('FileField failed to create directory (%d) at (%p).', array('%d' => $directory, '%p' => $path)), WATCHDOG_ERROR);
      return FALSE;
    }
  }
  return TRUE;
}


/**
 * The filefield widget for previously uploaded files.
 */
function filefield_file_edit_form(&$form, &$form_state, $field, $delta, $file) {
  $field_name_css = str_replace('_', '-', $field['field_name']);
  $id = 'filefield-'. $field_name_css .'-'. $delta .'-form';

  $classes = array(
    'filefield-'. $field_name_css .'-form',
    'filefield-file-form',
  );
  $widget = array(
    '#type' => 'filefield_file_edit',
    '#default_value' => $file,
    '#field' => $field,
    '#prefix' => '<div id="'. $id .'" class="'. implode(' ', $classes) .'"><div class="filefield-file-edit">',
    '#suffix' => '</div></div>',
  );

  // Buttons inside custom form elements are not registered by the Forms API,
  // so we make the "Delete" button a regular child element and not a part
  // of the filefield_file_upload widget.
  $widget['flags'] = array(
    '#type' => 'markup',
    '#value' => '',
    '#prefix' => '<div class="filefield-file-edit-flags">',
    '#suffix' => '</div>',
  );
  $widget['flags'][$field['field_name'] .'_'. $delta .'_delete'] = array(
    '#name' => $field['field_name'] .'_'. $delta .'_delete',
    '#type' => 'submit',
    '#value' => t('Delete'),
    '#submit' => array('filefield_file_edit_delete_submit'), // without JavaScript
    '#ahah' => array( // with JavaScript
      'path' => 'filefield/js/delete/'. $field['field_name'] .'/'. $field['type_name'] .'/'. $delta,
      'wrapper' => $id,
      'method' => 'replace',
      'effect' => 'fade',
    ),
    '#field' => $field,
    '#delta' => $delta,
    '#file' => $file,
  );
  // Only show the list checkbox if files are not forced to be listed.
  if (!$field['force_list']) {
    $widget['flags']['list'] = array(
      '#type' => 'checkbox',
      '#title' => t('List'),
      '#default_value' => $file['list'],
    );
  }

  $edit_widget_info = filefield_widget_for_file($field, $field['widget'], $file);
  $widget['edit'] = array(
    '#type' => empty($edit_widget_info)
                ? 'filefield_generic_edit' // as last-resort fallback
                : $edit_widget_info['form element'],
    '#field' => $field,
    '#delta' => $delta,
    '#file' => (object) $file,
    '#default_value' => $file,
    '#prefix' => '<div class="filefield-file-edit-widget">',
    '#suffix' => '</div>',
  );

  return $widget;
}

/**
 * Theme function for the file edit container element.
 */
function theme_filefield_file_edit($element) {
  return theme('filefield_container_item', $element);
}

/**
 * Custom value callback for file edit widgets, so that we don't need to rely
 * on a tree structure but can assemble the file to our likings.
 */
function filefield_file_edit_value($element, $edit = FALSE) {
  $file = $element['#default_value'];

  if (!is_array($edit)) {
    return $file;
  }

  $file_fixed_properties = array(
    'list'      => isset($edit['flags']['list'])
                    ? $edit['flags']['list']
                    : $file['list'],
    'delete'    => 0,
    'fid'       => $file['fid'],
    'uid'       => $file['uid'],
    'status'    => $file['status'],
    'filename'  => $file['filename'],
    'filepath'  => $file['filepath'],
    'filemime'  => $file['filemime'],
    'filesize'  => $file['filesize'],
    'timestamp' => $file['timestamp'],
  );

  if (is_array($edit['edit'])) {
    $file = array_merge($file, $edit['edit']);
  }
  $file = array_merge($file, $file_fixed_properties);

  // Also merge in other values that might come from other child form elements,
  // like the '_weight' property that CCK adds to this field.
  unset($edit['flags']);
  unset($edit['edit']);
  $file = array_merge($edit, $file);

  return $file;
}

/**
 * Submit callback for the "Delete" button next to each file item.
 */
function filefield_file_edit_delete_submit($form, &$form_state) {
  $field = $form_state['clicked_button']['#field'];
  $delta = $form_state['clicked_button']['#delta'];
  filefield_file_edit_delete($form_state, $field, $delta);

  // Rebuild the form with the new deleted-file state.
  node_form_submit_build_node($form, $form_state);
}

/**
 * Form callback for the "Delete" button with JavaScript enabled,
 * invoked by filefield_js(). Marks the file in the given field and delta
 * as deleted, or deletes it right away (depending on the context).
 */
function filefield_file_edit_delete_js(&$form, &$form_state, $field, $delta) {
  filefield_file_edit_delete($form_state, $field, $delta);
}

/**
 * Update the form state so that the file for the given field and delta
 * is marked as deleted.
 */
function filefield_file_edit_delete(&$form_state, $field, $delta) {
  $field_name = $field['field_name'];
  $file = &$form_state['values'][$field_name][$delta];

  if (isset($file['status']) && $file['status'] == FILE_STATUS_PERMANENT) {
    $file['delete'] = 1;
    $file = array(
      'fid' => 0,
      'replaced_file' => $file,
    );
  }
  else { // temporary file, get rid of it before it's even saved
    $empty_file = array(
      'fid' => 0,
      'replaced_file' => $file['replaced_file'], // remember permanent files from before
    );
    field_file_delete($file);
    $file = $empty_file;
  }
  return $file;
}

/**
 * Shared AHAH callback for uploads and deletions. It just differs in a few
 * unimportant details (what happens to the file, and which form is used as
 * a replacement) so these details are taken care of by a form callback.
 */
function filefield_js($field_name, $type_name, $delta, $form_callback) {
  $field = content_fields($field_name, $type_name);

  if (empty($field) || empty($_POST['form_build_id'])) {
    // Invalid request.
    print drupal_to_js(array('data' => ''));
    exit;
  }

  // Build the new form.
  $form_state = array('submitted' => FALSE);
  $form_build_id = $_POST['form_build_id'];
  $form = form_get_cache($form_build_id, $form_state);

  if (!$form) {
    // Invalid form_build_id.
    print drupal_to_js(array('data' => ''));
    exit;
  }
  // form_get_cache() doesn't yield the original $form_state,
  // but form_builder() does. Needed for retrieving the file array.
  $built_form = $form;
  $built_form_state = $form_state;
  $built_form += array('#post' => $_POST);
  $built_form = form_builder($_POST['form_id'], $built_form, $built_form_state);

  // Clean ids, so that the same element doesn't get a different element id
  // when rendered once more further down.
  form_clean_id(NULL, TRUE);

  // Perform the action for this AHAH callback.
  $form_callback($built_form, $built_form_state, $field, $delta);

  // Ask CCK for the replacement form element. Going through CCK gets us
  // the benefit of nice stuff like '#required' merged in correctly.
  module_load_include('inc', 'content', 'includes/content.node_form');
  $field_element = content_field_form($form, $built_form_state, $field, $delta);
  $delta_element = $field_element[$field_name][0]; // there's only one element in there

  // Add the new element at the right place in the form.
  if (module_exists('fieldgroup') && ($group_name = _fieldgroup_field_get_group($type_name, $field_name))) {
    $form[$group_name][$field_name][$delta] = $delta_element;
  }
  else {
    $form[$field_name][$delta] = $delta_element;
  }

  // Write the (unbuilt, updated) form back to the form cache.
  form_set_cache($form_build_id, $form, $form_state);

  // Render the form for output.
  $form += array(
    '#post' => $_POST,
    '#programmed' => FALSE,
  );
  drupal_alter('form', $form, array(), 'filefield_js');
  $form_state = array('submitted' => FALSE);
  $form = form_builder('filefield_js', $form, $form_state);
  $field_form = empty($group_name) ? $form[$field_name] : $form[$group_name][$field_name];
  $output = theme('status_messages') . drupal_render($field_form[$delta]);

  // AHAH is not being nice to us and doesn't know the "other" button (that is,
  // either "Upload" or "Delete") yet. Which in turn causes it not to attach
  // AHAH behaviours after replacing the element. So we need to tell it first.
  $javascript = drupal_add_js(NULL, NULL);
  if (isset($javascript['setting'])) {
    $output .= '<script type="text/javascript">jQuery.extend(Drupal.settings, '. drupal_to_js(call_user_func_array('array_merge_recursive', $javascript['setting'])) .');</script>';
  }

  // For some reason, file uploads don't like drupal_json() with its manual
  // setting of the text/javascript HTTP header. So use this one instead.
  print drupal_to_js(array('status' => TRUE, 'data' => $output));
  exit;
}


/**
 * Retrieve information about the widgets that are going to preview and
 * edit the single files that are uploaded in CCK's edit form.
 * This function also sorts the widgets in the way that the administrator
 * has specified for this field.
 */
function _filefield_file_widget_info($field_widget) {
  $file_widget_info = _filefield_file_widget_info_original();

  // Sort and enable the widgets according to previous admin settings or defaults.
  foreach ($file_widget_info as $file_widget_name => $info) {
    if (isset($field_widget['file_widgets'][$file_widget_name]['weight'])) {
      $info['weight'] = $field_widget['file_widgets'][$file_widget_name]['weight'];
    }
    else {
      // By default, the generic file edit widget should be last in the list
      // of possible widgets, and other new widgets should also not be
      // preferred to ones that already had their weight configured before.
      $info['weight'] = ($file_widget_name == 'filefield_generic') ? 1000 : 999;
    }

    if (isset($field_widget['file_widgets'][$file_widget_name]['enabled'])) {
      $info['enabled'] = $field_widget['file_widgets'][$file_widget_name]['enabled'];
    }
    else {
      // By default, enable only the generic file edit widget, so that newly
      // enabled modules don't show their widgets without approval of the admin.
      $info['enabled'] = ($file_widget_name == 'filefield_generic');
    }
    $file_widget_info[$file_widget_name] = $info;
  }
  return _filefield_sort_by_weight($file_widget_info);
}

function _filefield_file_widget_info_original() {
  static $file_widget_info;
  if (!isset($file_widget_info)) {

    foreach (module_implements('file_widget_info') as $module) {
      $function = $module .'_file_widget_info';
      $module_widget_info = $function();

      // Prepare the array for mass consumption.
      foreach ($module_widget_info as $widget_name => $info) {
        $info['module'] = $module;
        $info['name'] = $widget_name;
        $info['css'] = isset($info['css']) ? $info['css'] : array();
        $file_widget_info[$module .'_'. $widget_name] = $info;
      }
    }
    drupal_alter('file_widget_info', $file_widget_info);
  }
  return $file_widget_info;
}

/**
 * Helper function to sort file formatter/widget settings according to
 * user drag-n-drop reordering.
 */
function _filefield_sort_by_weight($items) {
  uasort($items, '_filefield_sort_by_weight_helper');
  foreach ($items as $delta => $item) {
    unset($items[$delta]['weight']);
  }
  return $items;
}

/**
 * Sort function for file formatter/widget order.
 * (copied form element_sort(), which acts on #weight keys)
 */
function _filefield_sort_by_weight_helper($a, $b) {
  $a_weight = (is_array($a) && isset($a['weight'])) ? $a['weight'] : 0;
  $b_weight = (is_array($b) && isset($b['weight'])) ? $b['weight'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}

/**
 * Retrieve information about the widgets that are going to display the
 * single files for the node view or other views.
 */
function _filefield_file_formatter_info($field) {
  $file_formatter_info = _filefield_file_formatter_info_original();

  // Sort and enable the formatters according to previous admin settings or defaults.
  foreach ($file_formatter_info as $formatter => $info) {
    if (isset($field['file_formatters'][$formatter]['weight'])) {
      $info['weight'] = $field['file_formatters'][$formatter]['weight'];
    }
    else {
      // By default, the generic file formatter should be last in the list
      // of possible formatters, and other new formatters should also not be
      // preferred to ones that already had their weight configured before.
      $info['weight'] = ($formatter == 'filefield_generic') ? 1000 : 999;
    }

    if (isset($field['file_formatters'][$formatter]['enabled'])) {
      $info['enabled'] = $field['file_formatters'][$formatter]['enabled'];
    }
    else {
      // By default, enable only the generic file formatter, so that newly
      // enabled modules don't show their formatters without approval of the admin.
      $info['enabled'] = ($formatter == 'filefield_generic');
    }
    $file_formatter_info[$formatter] = $info;
  }
  return _filefield_sort_by_weight($file_formatter_info);
}

function _filefield_file_formatter_info_original() {
  static $file_formatter_info;
  if (!isset($file_formatter_info)) {
    $file_formatter_info = array();

    foreach (module_implements('file_formatter_info') as $module) {
      $function = $module .'_file_formatter_info';
      $module_formatter_info = $function();

      // In order to construct the formatter name, we need the module name.
      foreach ($module_formatter_info as $formatter => $info) {
        $info['module'] = $module;
        $info['name'] = $formatter;
        $info['theme'] = $module .'_file_formatter_'. $formatter;
        $info['css'] = isset($info['css']) ? $info['css'] : array();
        $file_formatter_info[$module .'_'. $formatter] = $info;
      }
    }
    drupal_alter('file_formatter_info', $file_formatter_info);
  }
  return $file_formatter_info;
}

/**
 * Add all CSS files that extension file widgets might need, so that they
 * exist even if the form element has only been inserted by JavaScript.
 * Can also be used for formatter info arrays as those look similar.
 */
function _filefield_add_css($widget_or_formatter_info) {
  static $done = FALSE;
  if ($done) {
    return; // adding those files once should be enough for each request
  }
  foreach ($widget_or_formatter_info as $name => $info) {
    foreach ($info['css'] as $path) {
      drupal_add_css($path);
    }
  }
}

/**
 * Determine which widget will be used for displaying the edit form
 * for the given file.
 *
 * @return
 *   An array with info about the most appropriate file widget,
 *   or NULL if no widget is available to edit this file.
 */
function filefield_widget_for_file($field, $field_widget, $file) {
  $file_widget_info = _filefield_file_widget_info($field_widget);
  $file = (object) $file; // other modules only get to see objects

  $suitable_widget_info = array();
  foreach ($file_widget_info as $element_name => $info) {
    if (!$info['enabled']) {
      continue; // the admin disabled this widget
    }
    $handles_file = $info['suitability callback'];

    // Either $handles_file is TRUE already or it's a function that
    // will return TRUE if the widget handles this file.
    if (is_string($handles_file)) {
      $handles_file = $handles_file($field, $field_widget, $file);
    }
    if ($handles_file !== TRUE) {
      continue; // this widget is not interested in our file
    }
    $suitable_widget_info[] = $info;
  }
  // Return the most appropriate widget, if one was found.
  return empty($suitable_widget_info) ? NULL : reset($suitable_widget_info);
}

/**
 * Determine which formatter will be used for displaying the edit form
 * for the given file.
 *
 * @return
 *   An array with info about the most appropriate file formatter,
 *   or NULL if no formatter is available to display this file.
 */
function filefield_formatter_for_file($field, $file) {
  $file_formatter_info = _filefield_file_formatter_info($field);
  $file = (object) $file; // other modules only get to see objects

  $suitable_formatter_info = array();
  foreach ($file_formatter_info as $element_name => $info) {
    if (!$info['enabled']) {
      continue; // the admin disabled this widget
    }
    $handles_file = $info['suitability callback'];

    // Either $handles_file is TRUE already or it's a function that
    // will return TRUE if the formatter handles this file.
    if (is_string($handles_file)) {
      $handles_file = $handles_file($field, $file);
    }
    if ($handles_file !== TRUE) {
      continue; // this formatter is not interested in our file
    }
    $suitable_formatter_info[] = $info;
  }
  // Return the most appropriate formatter, if one was found.
  return empty($suitable_formatter_info) ? NULL : reset($suitable_formatter_info);
}

function _filefield_widget_suitability_strings($field_widget) {
  $file_widget_info = _filefield_file_widget_info($field_widget);
}


/**
 * Implementation of filefield's hook_file_widget_info().
 */
function filefield_file_widget_info() {
  return array(
    'generic' => array(
      'form element' => 'filefield_generic_edit',
      'suitability callback' => TRUE,
      'title' => t('Generic files'),
      'description' => t('An edit widget for all kinds of files.'),
    ),
  );
}

/**
 * The 'process' callback for 'filefield_generic_edit' form elements.
 * Called after defining the form and while building it, transforms the
 * barebone element array into an icon and and a text field for editing
 * the file description.
 */
function filefield_generic_edit_process($element, $edit, &$form_state, $form) {
  $field = $element['#field'];
  $delta = $element['#delta'];
  $file = $element['#file'];
  $url = file_create_url($file->filepath);

  $prefix = isset($element['#prefix']) ? $element['#prefix'] : '';
  $suffix = isset($element['#suffix']) ? $element['#suffix'] : '';
  $element['#prefix'] = $prefix .'<div class="filefield-generic-edit">';
  $element['#suffix'] = '</div>'. $suffix;

  $element['icon'] = array(
    '#type' => 'markup',
    '#value' => theme('filefield_icon', $file),
  );
  $element['description'] = array(
    '#type' => 'textfield',
    '#default_value' => empty($file->description)
                        ? $file->filename
                        : $file->description,
    '#maxlength' => 256,
    '#description' => t('Size: !size. Filename: !link', array(
      '!size' => format_size($file->filesize),
      '!link' => l($file->filename, $url),
    )),
    '#required' => TRUE,
    '#prefix' => '<div class="filefield-generic-edit-description">',
    '#suffix' => '</div>',
  );
  return $element;
}

/**
 * Theme function for the 'filefield_generic_edit' form element.
 */
function theme_filefield_generic_edit($element) {
  return theme('form_element', $element, $element['#children']);
}


/**
 * Implementation of hook_field_formatter_info().
 */
function filefield_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('Default'),
      'field types' => array('file'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}

/**
 * Theme function for the 'default' filefield formatter.
 */
function theme_filefield_formatter_default($element) {
  $file = $element['#item'];
  $field = content_fields($element['#field_name']);
  return theme('filefield', $field, $file);
}

/**
 * Theme function for any file that is managed by filefield.
 * It doesn't really format stuff by itself but rather redirects to other
 * formatters that are telling us they want to handle the concerned file.
 *
 * This function checks if the file may be shown and returns an empty string
 * if viewing the file is not allowed for any reason. If you need to display it
 * in any case, please use theme('filefield') instead.
 */
function theme_filefield($field, $file) {
  if (!filefield_view_access($field['field_name'])) {
    return '';
  }
  if ($field['force_list']) {
    $file['list'] = 1; // always show the files if that option is enabled
  }
  if (empty($file['list'])) {
    return '';
  }
  return theme('filefield_unguarded', $field, $file);
}

/**
 * Theme function for any file that is managed by filefield.
 * It doesn't really format stuff by itself but rather redirects to other
 * formatters that are telling us they want to handle the concerned file.
 *
 * This function does not check if the file may be shown, it returns markup
 * in any case (except if the file doesn't exist at all). If you need to check
 * permissions, please use theme('filefield_guarded') instead.
 */
function theme_filefield_unguarded($field, $file) {
  if (empty($file['fid']) || !is_file($file['filepath'])) {
    return '';
  }
  drupal_add_css(drupal_get_path('module', 'filefield') .'/filefield.css');

  $file_formatter_info = filefield_formatter_for_file($field, $file);
  if (empty($file_formatter_info)) {
    return '<div class="filefield-item filefield-item-empty"/>';
  }

  foreach ($file_formatter_info['css'] as $css_path) {
    drupal_add_css($css_path);
  }
  return '<div class="filefield-item">'.
    theme($file_formatter_info['theme'], $field, (object)$file) .'</div>';
}


/**
 * Implementation of filefield's hook_file_formatter_info().
 */
function filefield_file_formatter_info() {
  return array(
    'generic' => array(
      'suitability callback' => TRUE,
      'title' => t('Generic files'),
      'description' => t('Displays all kinds of files with an icon and a linked file description.'),
    ),
  );
}

/**
 * Theme function for the 'generic' single file formatter.
 */
function theme_filefield_file_formatter_generic($field, $file) {
  $path = $file->filepath;
  $url = file_create_url($path);
  $icon = theme('filefield_icon', $file);
  $desc = $file->description;
  return '<div class="filefield-formatter-generic">'. $icon . l($desc, $url) .'</div>';
}

/**
 * Return an image with an appropriate icon for the given file.
 * Remember to pass a file object and not an array.
 */
function theme_filefield_icon($file) {
  if (is_object($file)) {
    $file = (array) $file;
  }
  $dashed_mime = check_plain(strtr($file['filemime'], array('/' => '-')));

  if ($icon_url = filefield_icon_url($file)) {
    $icon = '<img class="field-icon-'. $dashed_mime .'" src="'. $icon_url .'" />';
  }
  return '<div class="filefield-icon field-icon-'. $dashed_mime .'">'. $icon .'</div>';
}


/**
 * Implementation of hook_file_download(). Yes, *that* hook that causes
 * any attempt for file upload module interoperability to fail spectacularly.
 */
function filefield_file_download($file) {
  $file = file_create_path($file);

  $result = db_query("SELECT * FROM {files} WHERE filepath = '%s'", $file);
  if (!$file = db_fetch_object($result)) {
    // We don't really care about this file.
    return;
  }

  // Find out if any filefield contains this file, and if so, which field
  // and node it belongs to. Required for later access checking.
  $cck_files = array();
  foreach (content_fields() as $field) {
    if ($field['type'] == 'file') {
      $db_info = content_database_info($field);
      $table = $db_info['table'];
      $fid_column = $db_info['columns']['fid']['column'];

      $columns = array('vid', 'nid');
      foreach ($db_info['columns'] as $property_name => $column_info) {
        $columns[] = $column_info['column'] .' AS '. $property_name;
      }
      $result = db_query("SELECT ". implode(', ', $columns) ."
                          FROM {". $table ."}
                          WHERE ". $fid_column ." = %d", $file->fid);

      while ($content = db_fetch_array($result)) {
        $content['field'] = $field;
        $cck_files[$field['field_name']][$content['vid']] = $content;
      }
    }
  }

  // If no filefield item is involved with this file, we don't care about it.
  if (empty($cck_files)) {
    return;
  }

  // If any node includes this file but the user may not view this field,
  // then deny the download.
  foreach ($cck_files as $field_name => $field_files) {
    if (!filefield_view_access($field_name)) {
      return -1;
    }
  }

  // So the overall field view permissions are not denied, but if access is
  // denied for a specific node containing the file, deny the download as well.
  // It's probably a little too restrictive, but I can't think of a
  // better way at the moment. Input appreciated.
  // (And yeah, node access checks also include checking for 'access content'.)
  $nodes = array();
  foreach ($cck_files as $field_name => $field_files) {
    foreach ($field_files as $revision_id => $content) {
      // Checking separately for each revision is probably not the best idea -
      // what if 'view revisions' is disabled? So, let's just check for the
      // current revision of that node.
      if (isset($nodes[$content['nid']])) {
        continue; // don't check the same node twice
      }
      $node = node_load($content['nid']);
      if (!node_access('view', $node)) {
        // You don't have permission to view the node this file is attached to.
        return -1;
      }
      $nodes[$content['nid']] = $node;
    }
  }

  // Well I guess you can see this file.
  $name = mime_header_encode($file->filename);
  $type = mime_header_encode($file->filemime);
  // Serve images and text inline for the browser to display rather than download.
  $disposition = ereg('^(text/|image/)', $file->filemime) ? 'inline' : 'attachment';
  return array(
    'Content-Type: '. $type .'; name='. $name,
    'Content-Length: '. $file->filesize,
    'Content-Disposition: '. $disposition .'; filename='. $name,
    'Cache-Control: private',
  );
}


/**
 * Implementation of hook_token_list():
 * Provide a user readable list of filefield tokens.
 */
function filefield_token_list($type = 'all') {
  if ($type == 'field' || $type == 'all') {
    $tokens = array();
    $tokens['file']['fid']                = t("File ID");
    $tokens['file']['description']        = t("File description");
    $tokens['file']['filename']           = t("File name");
    $tokens['file']['filepath']           = t("File path");
    $tokens['file']['filemime']           = t("File MIME type");
    $tokens['file']['filesize']           = t("File size (in bytes)");
    $tokens['file']['filesize_formatted'] = t("File size (pretty printed)");
    $tokens['file']['view']               = t("Fully formatted HTML file tag");
    return $tokens;
  }
}

/**
 * Implementation of hook_token_values():
 * Provide the concrete token values for a given file item.
 */
function filefield_token_values($type, $object = NULL) {
  if ($type == 'field') {
    $item = $object[0];
    $tokens['fid']                = $item['fid'];
    $tokens['description']        = $item['description'];
    $tokens['filename']           = $item['filename'];
    $tokens['filepath']           = $item['filepath'];
    $tokens['filemime']           = $item['filemime'];
    $tokens['filesize']           = $item['filesize'];
    $tokens['filesize_formatted'] = format_size($item['filesize']);
    $tokens['view']               = $item['view'];
    return $tokens;
  }
}


/**
 * Determine the most appropriate icon for the given file's mimetype.
 *
 * @return The URL of the icon image file, or FALSE if no icon could be found.
 */
function filefield_icon_url($file) {
  global $base_url;
  $theme = variable_get('filefield_icon_theme', 'protocons');

  if ($iconpath = _filefield_icon_path($file, $theme)) {
    return $base_url .'/'. $iconpath;
  }
  return FALSE;
}

function _filefield_icon_path($file, $theme = 'protocons') {
  // If there's an icon matching the exact mimetype, go for it.
  $dashed_mime = strtr($file['filemime'], array('/' => '-'));
  if ($iconpath = _filefield_create_icon_path($dashed_mime, $theme)) {
    return $iconpath;
  }
  // For a couple of mimetypes, we can "manually" tell a generic icon.
  if ($generic_name = _filefield_generic_icon_map($file)) {
    if ($iconpath = _filefield_create_icon_path($generic_name, $theme)) {
      return $iconpath;
    }
  }
  // Use generic icons for each category that provides such icons.
  foreach (array('audio', 'image', 'text', 'video') as $category) {
    if (strpos($file['filemime'], $category .'/') === 0) {
      if ($iconpath = _filefield_create_icon_path($category .'-x-generic', $theme)) {
        return $iconpath;
      }
    }
  }
  // Try application-octet-stream as last fallback.
  if ($iconpath = _filefield_create_icon_path('application-octet-stream', $theme)) {
    return $iconpath;
  }
  // Sorry, no icon can be found...
  return FALSE;
}

function _filefield_create_icon_path($iconname, $theme = 'protocons') {
  $iconpath = drupal_get_path('module', 'filefield')
    .'/icons/'. $theme .'/16x16/mimetypes/'. $iconname .'.png';
  if (file_exists($iconpath)) {
    return $iconpath;
  }
  return FALSE;
}

function _filefield_generic_icon_map($file) {
  switch ($file['filemime']) {
    // Word document types.
    case 'application/msword':
    case 'application/vnd.ms-word.document.macroEnabled.12':
    case 'application/vnd.oasis.opendocument.text':
    case 'application/vnd.oasis.opendocument.text-template':
    case 'application/vnd.oasis.opendocument.text-master':
    case 'application/vnd.oasis.opendocument.text-web':
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
    case 'application/vnd.stardivision.writer':
    case 'application/vnd.sun.xml.writer':
    case 'application/vnd.sun.xml.writer.template':
    case 'application/vnd.sun.xml.writer.global':
    case 'application/vnd.wordperfect':
    case 'application/x-abiword':
    case 'application/x-applix-word':
    case 'application/x-kword':
    case 'application/x-kword-crypt':
      return 'x-office-document';

    // Spreadsheet document types.
    case 'application/vnd.ms-excel':
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
    case 'application/vnd.oasis.opendocument.spreadsheet':
    case 'application/vnd.oasis.opendocument.spreadsheet-template':
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
    case 'application/vnd.stardivision.calc':
    case 'application/vnd.sun.xml.calc':
    case 'application/vnd.sun.xml.calc.template':
    case 'application/vnd.lotus-1-2-3':
    case 'application/x-applix-spreadsheet':
    case 'application/x-gnumeric':
    case 'application/x-kspread':
    case 'application/x-kspread-crypt':
      return 'x-office-spreadsheet';

    // Presentation document types.
    case 'application/vnd.ms-powerpoint':
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
    case 'application/vnd.oasis.opendocument.presentation':
    case 'application/vnd.oasis.opendocument.presentation-template':
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
    case 'application/vnd.stardivision.impress':
    case 'application/vnd.sun.xml.impress':
    case 'application/vnd.sun.xml.impress.template':
    case 'application/x-kpresenter':
      return 'x-office-presentation';

    // Compressed archive types.
    case 'application/zip':
    case 'application/x-zip':
    case 'application/stuffit':
    case 'application/x-stuffit':
    case 'application/x-7z-compressed':
    case 'application/x-ace':
    case 'application/x-arj':
    case 'application/x-bzip':
    case 'application/x-bzip-compressed-tar':
    case 'application/x-compress':
    case 'application/x-compressed-tar':
    case 'application/x-cpio-compressed':
    case 'application/x-deb':
    case 'application/x-gzip':
    case 'application/x-java-archive':
    case 'application/x-lha':
    case 'application/x-lhz':
    case 'application/x-lzop':
    case 'application/x-rar':
    case 'application/x-rpm':
    case 'application/x-tzo':
    case 'application/x-tar':
    case 'application/x-tarz':
    case 'application/x-tgz':
      return 'package-x-generic';

    // Script file types.
    case 'application/ecmascript':
    case 'application/javascript':
    case 'application/mathematica':
    case 'application/vnd.mozilla.xul+xml':
    case 'application/x-asp':
    case 'application/x-awk':
    case 'application/x-cgi':
    case 'application/x-csh':
    case 'application/x-m4':
    case 'application/x-perl':
    case 'application/x-php':
    case 'application/x-ruby':
    case 'application/x-shellscript':
    case 'text/vnd.wap.wmlscript':
    case 'text/x-emacs-lisp':
    case 'text/x-haskell':
    case 'text/x-literate-haskell':
    case 'text/x-lua':
    case 'text/x-makefile':
    case 'text/x-matlab':
    case 'text/x-python':
    case 'text/x-sql':
    case 'text/x-tcl':
      return 'text-x-script';

    // HTML aliases.
    case 'application/xhtml+xml':
      return 'text-html';

    // Executable types.
    case 'application/x-macbinary':
    case 'application/x-ms-dos-executable':
    case 'application/x-pef-executable':
      return 'application-x-executable';

    default:
      return FALSE;
  }
}
